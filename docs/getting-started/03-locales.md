# Getting Started, Part 3: Locales


**Already familiar with locales?** Feel free to [skip this part](04-setup.md) if you are coming from another I18n library and already know about locales.

## Locales and Locale Codes

A locale can be represented by a single String and encode a whole range of information.

Nii has a first class representation of locales:

``` ruby
# Parsing a locale code with Nii::Locale
locale = Nii::Locale.new 'en-US'
locale.language # => 'en'
locale.region   # => 'US'

# Generating a locale code
locale = Nii::Locale.new language: 'en', region: 'US'
locale.code # => 'en-US'

# A more complex example
locale = Nii::Locale.new 'es-Latn-MX-u-cu-usd-x-informal'
locale.language  # => "es"       - Spanish
locale.script    # => "Latn"     - the default for Spanish, could have been omitted
locale.region    # => "MX"       - Mexico
locale.variants  # => []         - no variants
locale.currency  # => "usd"      - US Dollar
locale.formality # => "informal" - use "tú" instead of "usted"
```

**This locale format is standardized by the IETF, and can be used to exchange locale information between Nii and other I18n solutions.**

We'll keep using `Nii::Locale` in this part of the introduction, but you never have to interact with it. It is handy if you want to generate locale codes from a form or links (think "switch language" or "switch region"), but completely optional. It is used by `Nii::Context` under the hood, and helpful to illustrate how locales work in Nii.

## What's in a Locale?
A well formed locale code may consist of the following:

* A **language** code. This is the only mandatory part. To represent a locale without a language code, you may use `und` or `root`.
* A **region** or **territory** (Unicode uses both phrases interchangeably). This is a two letter or three digit code. `001` represents the world.
* A **script**, represented by a four letter code, like `Latn` or `Hebr`.
* A list of language **variants**. Most commonly this is one, at most, but in rare cases you may have multiple variants in one locale.
* A list of extensions. Each group of extensions starts with a one letter identifier:
    * `i`: Extension for irregular language tags. Nii will resolve these to their regular form before handing them to `Nii::Locale`.
    * `u`: Unicode extensions. Nii currently respects the following unicode extensions:
      * `ca`: The **calendar algorithm** – what calendar system to use for dates.
      * `cu`: The **currency format** - how to format money.
      * `co`: The **collation type** – to determine sort order.
      * `cu`: The locale's **currency**.
      * `em`: The preferred **emoji** representation.
      * `fw`: The **first day of the week**.
      * `hc`: The locale's **hour cycle**.
      * `mc`: The locale's **measurement system**.
      * `nu`: The **numbering system**.
      * `rg`: A **region override** ("the user is in region X but would like things like the currency to default to the appropriate values for Y").
      * `sd`: The locale's **regional subdivision**.
      * `tz`: The locale's **time zone**.
    * `x`: Private extensions. Nii implements the following private extension:
      * The locale's **formality**: Either `formal`, `informal`, or `avoid`. This is useful for languages that still differentiate between formal and informal pronouns.
    * Any other extensions are ignored (and will not be part of the code generated by Nii).

Different parts are separated by a dash or underscore.

## Relationships between Locales

You likely don't want localize your application from ground up for each and every single possible locale.

This is why it's handy that locales have logical relationships with another. This way Nii can determine what the best way is to serve content for a given locale.

To demonstrate this, here are a few logical operations you can perform on locale objects:

``` ruby
Nii::Locale.new("de").superset_of? "de-AT" # => true
Nii::Locale.new("de").subset_of?   "de-AT" # => false

Nii::Locale.new("de")    & Nii::Locale.new(region: "AT")   # => #<Nii::Locale:de-AT>
Nii::Locale.new("de-DE") & Nii::Locale.new(script: "Latn") # => #<Nii::Locale:de-Latn-DE>
Nii::Locale.new("de")    | Nii::Locale.new("de-AT")        # => #<Nii::Locale:de>
Nii::Locale.new("de")    & Nii::Locale.new("en-US")        # => #<Nii::LocalePreference:[]>
Nii::Locale.new("de")    | Nii::Locale.new("en-US")        # => #<Nii::LocalePreference:[#<Nii::Locale:de>, #<Nii::Locale:en-US>]>
```

You could use this to influence the locale negotiation for a context:

``` ruby
context = Nii::Context.new('zh-Hant', 'en-US')
context.locale_preference &= 'Latn' # only include locales using Latin script
context.locale(true).code           # (passing true forces locale negotiation)
# => "en-Latn-US"
```

The context object will perform locale negotiation on its own once all parts are in place (once it knows how to look for message templates, we'll get to that *very* soon).

## Local Inheritance

When Nii looks for locale data and message templates, it will use a locale inheritance chain:

``` ruby
Nii::Locale.new('de-DE-x-informal').lookup
# => ["de-DE-x-informal", "de-DE", "de-x-informal", "de", "root"]
```

This means any content you have defined for `de` will also apply to `de-DE-x-informal`, unless more specific content exists.

## Further Reading
* **Next Chapter: [Part 4: Setup & Configuration](04-setup.md)**
* IETF: [BCP 47 (RFC 5646) – Tags for Identifying Languages](https://tools.ietf.org/html/bcp47)
* Unicode Technical Standard #35: [What is a Locale?](https://www.unicode.org/reports/tr35/tr35-39/tr35.html#Locale)

